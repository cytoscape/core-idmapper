package org.nrnb.idmapper;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;

import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;

import org.cytoscape.model.CyColumn;
import org.cytoscape.model.CyTable;
import org.cytoscape.property.CyProperty;
import org.cytoscape.service.util.CyServiceRegistrar;
import org.cytoscape.session.CySession;
import org.cytoscape.session.CySessionManager;
import org.cytoscape.task.AbstractTableColumnTask;
import org.cytoscape.work.ProvidesTitle;
import org.cytoscape.work.TaskMonitor;
import org.cytoscape.work.Tunable;
import org.cytoscape.work.undo.UndoSupport;
import org.cytoscape.work.util.ListSingleSelection;

/**
 * A column task which uses the Id Mapping service BridgeDB.
 *
 *
 * @author cmzmasek 
 * @author Adam Treister - tunables reordered, prompts changed
 *
 *         Full list of source databases can be found here:
 * 
 *         //https://github.com/bridgedb/BridgeDb/blob/master/org.bridgedb.bio/
 *         resources/org/bridgedb/bio/datasources.txt
 *         
 *         common sources are enumerated in MappingSource.java
 *
 */
public class MapColumnTask extends AbstractTableColumnTask {

//	public static final boolean DEBUG = true;
	public static final boolean VERBOSE = false;
	private static Species saveSpecies = Species.Mouse;
	private static MappingSource saveTarget = MappingSource.ENSEMBL;
	private  final CyServiceRegistrar registrar;
	MapColumnTask(final UndoSupport undoSupport, final CyColumn column, final CyServiceRegistrar reg) {
		super(column);
		registrar = reg;
		// get species from property
		Species.buildMaps();
		saveSpecies = getSpeciesProperty();
		getSpecies_selection().setSelectedValue(saveSpecies.name());
//		species_selection.setSelectedValue(saveSpecies.name());			ORIG
		final List<String> names = column.getValues(String.class);
		MappingSource src = MappingSource.guessSource(names);
		source_selection.setSelectedValue(src.descriptor());
		String[] strs = MappingSource.allStringsExcept(src.descriptor());
		List<String> strList = new ArrayList<String>();
		for (String s : strs) 
			strList.add(s);
//		target_selection.setPossibleValues(strList);
		target_selection.setSelectedValue(saveTarget.descriptor());
	}
	//------------------------------------------------------------------------
	// 	These are unused accessors to a property to keep the species.   
	//	Must be an easier way to get persistance in a session
	Species getSpeciesProperty()
	{
		CySessionManager sessionMgr = registrar.getService(CySessionManager.class);
		if (sessionMgr != null) {
			CySession session = sessionMgr.getCurrentSession();
			if (session != null)
			{
			    Set<CyProperty<?>> props = session.getProperties();
			    if (props != null)
			    {
			    	for (CyProperty<?> prop : props)
			    	{
			    		if (prop.getProperties() instanceof Properties)
			    		{		
			    			Properties p = (Properties) prop.getProperties();
				    		String speciesProp = p.getProperty("species");
//				    		System.out.println(speciesProp);
				    		if (speciesProp != null)
				    			saveSpecies = Species.lookup(speciesProp);
		    		
			    		}
			    	}
			    }
			}
		}
//	    return Species.lookupSpecies(species);
	    return saveSpecies;
	}
	void putSpeciesProperty(String newSpeciesName)
	{
		CySessionManager sessionMgr = registrar.getService(CySessionManager.class);
		if (sessionMgr != null) {
			CySession session = sessionMgr.getCurrentSession();
			if (session != null)
			{
			    Set<CyProperty<?>> props = session.getProperties();
			    if (props != null)
			    {
//			    	SimpleCyProperty<Properties> newProp = new SimpleCyProperty<Properties>("Species.properties", props, Properties.class,
//							CyProperty.SavePolicy.SESSION_FILE); 
//			    			props.add(newProp);
			    }
			}
		}
	    return ;
	}
	
	void saveSpeciesProperty(Species cur)
	{
		saveSpecies = cur;
	}
	
	
	
	@ProvidesTitle
	public String getTitle() {		return "ID Mapping";	}

	//------------------------------------------------------------------------
	// look at AbstractCyNetworkReader:98 for an example of Tunables with methods

//	@Tunable(description = "Species")
//	public ListSingleSelection<String> species_selection = new ListSingleSelection<String>(Species.fullNames());
	
	private ListSingleSelection<String> speciesList;
	
	@Tunable(description="Species", gravity=1.0)
	public ListSingleSelection<String> getspecies_selection()
	{
		System.out.println("getSpecies_selection");
		if (speciesList == null)
			speciesList =  new ListSingleSelection<String>(Species.fullNames());
		return speciesList;
	}

	public void setspecies_selection(ListSingleSelection<String> list)
	{
		System.out.println("setSpecies_selection");
		String cur = speciesList.getSelectedValue();
		int idx = cur.indexOf("(");
		if (idx >0)
			cur = cur.substring(0, idx);
		saveSpecies = Species.lookup(cur);
	}
	//------------------------------------------------------------------------
	public String new_column_name = "";

	
	// look at AbstractCyNetworkReader:98 for an example of Tunables with methods
	
	@Tunable(description="Map from")
	public ListSingleSelection<String> source_selection = new ListSingleSelection<String>(MappingSource.allStrings());

	@Tunable(description="To")
	public ListSingleSelection<String> target_selection	= new ListSingleSelection<String>(MappingSource.allStrings());

	@Tunable(description="Force single ")
	public boolean only_use_one = true;

	@SuppressWarnings("rawtypes")
	@Override
	public void run(final TaskMonitor taskMonitor) {
		final MappingSource target = MappingSource.nameLookup(target_selection.getSelectedValue());
		final MappingSource source = MappingSource.nameLookup(source_selection.getSelectedValue());
		String species = getSpecies_selection().getSelectedValue();
//		String species = species_selection.getSelectedValue();
//		species = species.substring(0, species.indexOf(" ("));
		saveSpecies = Species.lookup(species);
//		System.out.println("saving species as " + saveSpecies.name());
		saveTarget = target;
		boolean source_is_list = false;
		if (column.getType() == List.class)
			source_is_list = true;

		final List values = column.getValues(column.getType());

		final List<String> ids = new ArrayList<String>();
		for (final Object v : values) {
			// System.out.println(v);
			if (v != null) {
				if (source_is_list) {
					for (final Object lv : (List) v)
						MappingUtil.addCleanedStrValueToList(ids, lv);
				} else
					MappingUtil.addCleanedStrValueToList(ids, v);
			}
		}

		final Set<String> matched_ids;
		final Set<String> unmatched_ids;
		final Map<String, IdMapping> res;
		try {
			final BridgeDbIdMapper map = new BridgeDbIdMapper();
			res = map.map(ids, source.system(), target.system(), saveSpecies.name(), saveSpecies.name());
			matched_ids = map.getMatchedIds();
			unmatched_ids = map.getUnmatchedIds();
		} catch (final Exception e) {
			SwingUtilities.invokeLater(new Runnable() {
				@Override
				public void run() {
					JOptionPane.showMessageDialog(null, e.getMessage(), "ID Mapping Error", JOptionPane.ERROR_MESSAGE);
				}
			});
			return;
		}

		if (VERBOSE) {
			System.out.println();
			System.out.println("Unmatched:");
			if (unmatched_ids != null) {
				for (final String u : unmatched_ids) {
					System.out.println(u);
				}
			}
			System.out.println();
			System.out.println("Matched:");
			if (matched_ids != null) {
				for (final String u : matched_ids) {
					System.out.println(u);
				}
			}
			System.out.println();
		}
		new_column_name = target.descriptor();
		new_column_name = MappingUtil.makeNewColumnName(new_column_name,
				source.descriptor(), new_column_name, column);

		boolean all_unique = true;
		int non_unique = 0;
		int unique = 0;
		int min = Integer.MAX_VALUE;
		int max = 0;

		if (res != null)
			for (final Entry<String, IdMapping> entry : res.entrySet()) {
				final Set<String> v = entry.getValue().getTargetIds();
				if (v != null) {
					if (v.size() > 1) {
						all_unique = false;
						++non_unique;
						if (v.size() > max)		max = v.size();
						if (v.size() < min)		min = v.size();
					} else
						++unique;
				}
			}

		final CyTable table = column.getTable();
		
// TODO -- #3666 add the new column after the original, not at end of table
//		int index = getColumnIndex(table, column);
//		System.out.println("Index = " + index);
		
		
		boolean many_to_one = false;
		if (matched_ids.size() > 0) {
			boolean all_single = false;
			if (only_use_one) 
				table.createColumn(new_column_name, String.class, false);	//index, 
			else {  
				all_single = MappingUtil.isAllSingle(source_is_list, res, column, table);
				if (all_single) 
					table.createColumn(new_column_name, String.class, false);		//index, 
				 else 
					table.createListColumn(new_column_name, String.class, false);	//index, 
			}
			many_to_one = MappingUtil.fillNewColumn(source_is_list, res, table, column, new_column_name,
					only_use_one || all_single);

//			moveLastColumnTo(table, index+1);
//			System.out.println("moveLastColumnTo " + (index+1));
		}
		String targ = target.descriptor();
		String src = source.descriptor();
		final String msg = MappingUtil.createMsg(new_column_name, targ, src, ids, matched_ids, all_unique, non_unique,
				unique, min, max, many_to_one);

//		taskMonitor.showMessage(TaskMonitor.Level.INFO, msg);

		putSpeciesProperty(saveSpecies.name());
		SwingUtilities.invokeLater(new Runnable() {
			@Override
			public void run() {
				JOptionPane.showMessageDialog(null, msg, "ID Mapping Result",
						(matched_ids.size() < 1 ? JOptionPane.WARNING_MESSAGE : JOptionPane.INFORMATION_MESSAGE));
			}
		});

	}

//	 #3666
// 	private void moveLastColumnTo(CyTable table, int index) {
//		JTable nativeTable = table.
//		Collection<CyColumn> cols = table.getColumnModel();
//		if (cols instanceof ArrayList)
//		{
//			List<CyColumn> colList = (ArrayList<CyColumn>) cols;
//			CyColumn lastCol = colList.get(colList.size()-1);
//			colList.remove(lastCol);
//			colList.add(index, lastCol);
//		}
//	}

//	private int getColumnIndex(CyTable table, CyColumn column) {
//		Collection<CyColumn> cols = table.getColumns();
//		if (cols instanceof ArrayList)
//		{
//			List<CyColumn> colList = (ArrayList<CyColumn>) cols;
//			for (int i=0; i < colList.size(); i++)
//			{
//				CyColumn col = colList.get(i);
//				if (col == column)
//					return i;
//			}
//		}
//		return -1;
//	}

}
